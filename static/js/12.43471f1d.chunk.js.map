{"version":3,"sources":["components/editor/core/index.ts","components/editor/core/errors.ts"],"names":["_specificationSnapshot","generateAPI","Object","fromEntries","entries","getSpecificationSnapshot","map","elementName","specification","args","forEach","instanceID","addInstance","instance","getInstance","argLabels","length","arg","getArgType","removeInstance","items","category","push","type","api","elements","name","types","join","buildProgram","code","instructions","__transpile","__findSingleArgParam","instruction","InvalidArgumentError","__verifyArgParams","argObj","isBlock","exptParams","param","origParams","keys","includes","InvalidInstructionError","Array","filter","__buildInputSnapshotArgument","codeArgument","value","toString","argElem","treeSnapshotInputArgument","argMap","__buildInputSnapshotInstruction","codeInstruction","treeSnapshotInputInstruction","scope","item","snapshot","process","routine","crumbs","generateFromSnapshot","Promise","resolve","yamlToJson","e","_err","console","log","mark","message","reason","__verifyStructureValidity","generateSnapshot","resetProgram","resetSyntaxTree","SyntaxError","_name","_message","this","Error"],"mappings":"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","file":"static/js/12.43471f1d.chunk.js","sourcesContent":["import { load as yamlToJson } from 'js-yaml';\n\nimport {\n    ITreeSnapshotInput,\n    generateFromSnapshot,\n    generateSnapshot,\n    resetSyntaxTree,\n    getSpecificationSnapshot,\n} from '@sugarlabs/musicblocks-v4-lib';\n\n/** @todo these should be exposed */\nimport {\n    TElementType,\n    IElementSpecificationSnapshot,\n} from '@sugarlabs/musicblocks-v4-lib/@types/specification';\n/** @todo these should be exposed */\nimport {\n    ITreeSnapshotDataInput,\n    ITreeSnapshotExpressionInput,\n    ITreeSnapshotStatementInput,\n    ITreeSnapshotBlockInput,\n} from '@sugarlabs/musicblocks-v4-lib/@types/syntaxTree';\n/** @todo these should not be required */\nimport {\n    addInstance,\n    getInstance,\n    removeInstance,\n} from '@sugarlabs/musicblocks-v4-lib/syntax/warehouse/warehouse';\n\nimport { ICodeArgumentObj, ICodeArgument, ICodeInstruction } from '../@types';\n\nimport { InvalidArgumentError, InvalidInstructionError } from './errors';\n\n// -- private variables ----------------------------------------------------------------------------\n\ninterface IElementSpecificationSnapshotWithArgs extends IElementSpecificationSnapshot {\n    args: [string, string[]][] | null;\n}\n\n/**\n * Snapshot entry table object with key-value pairs of element name and corresponding element\n * specification snapshot.\n */\nlet _specificationSnapshot: {\n    [name: string]: IElementSpecificationSnapshotWithArgs;\n};\n\n// -- public functions -----------------------------------------------------------------------------\n\n/**\n * Generates the API for the loaded specification.\n * @returns list of valid instruction signatures\n */\nexport function generateAPI(): string {\n    _specificationSnapshot = Object.fromEntries(\n        Object.entries(getSpecificationSnapshot()).map(([elementName, specification]) => [\n            elementName,\n            { ...specification, args: null },\n        ]),\n    );\n\n    /**\n     * @todo args should be part of the supplied specification snapshot\n     * Add args to the specification.\n     */\n\n    Object.entries(_specificationSnapshot).forEach(([elementName, _]) => {\n        const instanceID = addInstance(elementName);\n        const instance = getInstance(instanceID)!.instance;\n\n        _specificationSnapshot[elementName]['args'] =\n            instance.argLabels.length === 0\n                ? null\n                : (instance.argLabels.map((arg) => [arg, instance.getArgType(arg)]) as [\n                      string,\n                      string[],\n                  ][]);\n\n        removeInstance(instanceID);\n    });\n\n    /**\n     * Group syntax elements by categories.\n     */\n\n    const items: {\n        [key: string]: [string, TElementType, [string, string[]][] | null][];\n    } = {};\n\n    Object.entries(_specificationSnapshot).forEach(([elementName, specification]) => {\n        const category = specification.category;\n\n        if (!(category in items)) {\n            items[category] = [];\n        }\n\n        items[category].push([elementName, specification.type, specification.args]);\n    });\n\n    /**\n     * Generate API.\n     */\n\n    const api: string[] = [];\n\n    Object.entries(items).forEach(([category, elements]) => {\n        api.push(`# \"${category}\" elements\\n# ------------------------`);\n        elements.forEach(([name, type, args]) => {\n            if (type === 'Data') {\n                api.push(`- [instruction]:\\n    [param]:\\n      ${name}: string`);\n            } else if (type === 'Expression') {\n                if (args === null) {\n                    // not possible\n                } else if (args.length === 1) {\n                    api.push(\n                        `- [instruction]:\\n    ${name}:\\n${args\n                            .map(([name, types]) => `      ${name}: ${types.join('|')}`)\n                            .join('\\n')}`,\n                    );\n                } else {\n                    api.push(\n                        `- [instruction]:\\n    [param]:\\n      ${name}:\\n${args\n                            .map(([name, types]) => `        ${name}: ${types.join('|')}`)\n                            .join('\\n')}`,\n                    );\n                }\n            } else if (type === 'Statement') {\n                if (args === null) {\n                    api.push(`- ${name}`);\n                } else if (args.length === 1) {\n                    api.push(`- ${name}: ${args[0][1].join('|')}`);\n                } else {\n                    api.push(\n                        `- ${name}:\\n${args\n                            .map(([name, types]) => `    ${name}: ${types.join('|')}`)\n                            .join('\\n')}`,\n                    );\n                }\n            } else if (type === 'Block') {\n                if (args === null) {\n                    api.push(`- ${name}:\\n    scope:\\n      - [instruction]\\n      - ...`);\n                } else {\n                    api.push(\n                        `- ${name}:\\n${args\n                            .map(([name, types]) => `    ${name}: ${types.join('|')}`)\n                            .join('\\n')}\\n    scope:\\n      - [instruction]\\n      - ...`,\n                    );\n                }\n            }\n        });\n        api.push('\\n');\n    });\n\n    return api.join('\\n');\n}\n\n/**\n * Validates code, transpiles it, and generates the Syntax Tree in the Programming Engine.\n * @param code editor's code\n * @returns a `Promise` that returns whether the process was successful\n */\nexport function buildProgram(code: string): Promise<boolean> {\n    let instructions: ICodeInstruction[];\n\n    function __verifyStructureValidity(): boolean {\n        try {\n            instructions = yamlToJson(code) as ICodeInstruction[];\n            return instructions instanceof Array;\n        } catch (e) {\n            const _err = e as {\n                mark: {\n                    buffer: string;\n                    column: number;\n                    line: number;\n                    name: string | null;\n                    position: number;\n                };\n                message: string;\n                name: string;\n                reason: string;\n            };\n            console.log({\n                mark: _err.mark,\n                message: _err.message,\n                name: _err.name,\n                reason: _err.reason,\n            });\n            return false;\n        }\n    }\n\n    function __transpile(): void {\n        function __findSingleArgParam(instruction: string): string {\n            const args = _specificationSnapshot[instruction].args;\n            if (args === null) {\n                throw new InvalidArgumentError(`\"${instruction}\" does not take arguments`);\n            } else if (args.length !== 1) {\n                throw new InvalidArgumentError(\n                    `\"${instruction}\" takes ${args.length} arguments but only 1 argument supplied`,\n                );\n            }\n\n            return args[0][0];\n        }\n\n        function __verifyArgParams(instruction: string, argObj: ICodeArgument): void {\n            const args = _specificationSnapshot[instruction].args;\n\n            if (args === null) {\n                throw new InvalidArgumentError(`\"${instruction}\" does not take arguments`);\n            }\n\n            const isBlock = _specificationSnapshot[instruction].type === 'Block';\n\n            const exptParams = args.map(([param, _]) => param);\n            const origParams = Object.keys(argObj);\n\n            if (isBlock) {\n                if (!origParams.includes('scope')) {\n                    throw new InvalidInstructionError(`\"${instruction}\" expects a scope`);\n                }\n\n                if (!((argObj as ICodeArgumentObj)['scope'] instanceof Array)) {\n                    throw new InvalidInstructionError(\n                        `\"${instruction}\" supplied with invalid scope`,\n                    );\n                }\n\n                exptParams.push('scope');\n            }\n\n            if (exptParams.length !== origParams.length) {\n                throw new InvalidArgumentError(\n                    `invalid number of arguments supplied for \"${instruction}\"`,\n                );\n            }\n\n            if (exptParams.filter((param) => !origParams.includes(param)).length !== 0) {\n                throw new InvalidArgumentError(`invalid arguments supplied for \"${instruction}\"`);\n            }\n        }\n\n        function __buildInputSnapshotArgument(\n            instruction: string,\n            param: string,\n            codeArgument: ICodeArgument,\n        ): ITreeSnapshotDataInput | ITreeSnapshotExpressionInput {\n            // code argument is a literal\n            if (typeof codeArgument !== 'object') {\n                return {\n                    elementName:\n                        typeof codeArgument === 'boolean'\n                            ? 'value-boolean'\n                            : typeof codeArgument === 'number'\n                            ? 'value-number'\n                            : 'value-string',\n                    value: codeArgument.toString(),\n                };\n            }\n\n            if (Object.keys(codeArgument).length !== 1) {\n                throw new InvalidArgumentError(\n                    `invalid argument for parameter \"${param}\" of \"${instruction}\"`,\n                );\n            }\n\n            // there's only one arg element\n            const [argElem, args] = Object.entries(codeArgument)[0];\n\n            // single arg but supplied as key-value pair\n            if (param === argElem) {\n                return __buildInputSnapshotArgument(instruction, param, args);\n            }\n\n            if (!(argElem in _specificationSnapshot)) {\n                throw new InvalidInstructionError(\n                    `\"${argElem}\" is not a valid argument for \"${argElem}\"`,\n                );\n            }\n\n            const specification = _specificationSnapshot[argElem];\n            if (specification.type === 'Data') {\n                if (typeof args === 'string') {\n                    return {\n                        elementName: argElem,\n                        value: args,\n                    };\n                }\n\n                throw new InvalidArgumentError(`invalid argument for 'Data' element \"${argElem}\"`);\n            } else if (specification.type === 'Expression') {\n                const treeSnapshotInputArgument: ITreeSnapshotExpressionInput = {\n                    elementName: '',\n                    argMap: null,\n                };\n\n                treeSnapshotInputArgument.elementName = argElem;\n\n                // single arg\n                if (typeof args !== 'object' || Object.keys(args).length === 1) {\n                    // can throw error\n                    const param = __findSingleArgParam(argElem);\n\n                    treeSnapshotInputArgument.argMap = Object.fromEntries([\n                        [param, __buildInputSnapshotArgument(argElem, param, args)],\n                    ]);\n                }\n                // multiple args\n                else {\n                    // can throw error\n                    __verifyArgParams(argElem, args);\n\n                    treeSnapshotInputArgument.argMap = Object.fromEntries(\n                        Object.entries(args).map(([param, arg]) => [\n                            param,\n                            __buildInputSnapshotArgument(argElem, param, arg),\n                        ]),\n                    );\n                }\n\n                return treeSnapshotInputArgument;\n            } else {\n                throw new InvalidArgumentError(\n                    `\"${argElem}\" is not a 'Data' or 'Expression' element`,\n                );\n            }\n        }\n\n        function __buildInputSnapshotInstruction(\n            codeInstruction: ICodeInstruction,\n        ): ITreeSnapshotStatementInput | ITreeSnapshotBlockInput {\n            // code instruction is a string\n            if (typeof codeInstruction === 'string') {\n                if (!(codeInstruction in _specificationSnapshot)) {\n                    throw new InvalidInstructionError(\n                        `\"${codeInstruction}\" is not a valid instruction`,\n                    );\n                }\n\n                return {\n                    elementName: codeInstruction,\n                    argMap: null,\n                };\n            }\n            // code instruction is an object\n            else {\n                if (Object.keys(codeInstruction).length !== 1) {\n                    throw new InvalidInstructionError('wrong instruction format encountered');\n                }\n\n                // there's only one instruction\n                const [instruction, args] = Object.entries(codeInstruction)[0];\n\n                if (!(instruction in _specificationSnapshot)) {\n                    throw new InvalidInstructionError(\n                        `\"${codeInstruction}\" is not a valid instruction`,\n                    );\n                }\n\n                const treeSnapshotInputInstruction:\n                    | ITreeSnapshotStatementInput\n                    | ITreeSnapshotBlockInput = {\n                    elementName: '',\n                    argMap: null,\n                };\n\n                treeSnapshotInputInstruction.elementName = instruction;\n\n                // single arg\n                if (typeof args !== 'object' || Object.keys(args).length === 1) {\n                    // can throw error\n                    const param = __findSingleArgParam(instruction);\n\n                    treeSnapshotInputInstruction.argMap = Object.fromEntries([\n                        [param, __buildInputSnapshotArgument(instruction, param, args)],\n                    ]);\n                }\n                // multiple args\n                else {\n                    // can throw error\n                    __verifyArgParams(instruction, args);\n\n                    treeSnapshotInputInstruction.argMap = Object.fromEntries(\n                        Object.entries(args)\n                            .filter(([param, _]) => param !== 'scope')\n                            .map(([param, arg]) => [\n                                param,\n                                __buildInputSnapshotArgument(instruction, param, arg),\n                            ]),\n                    );\n\n                    if ('scope' in args) {\n                        (treeSnapshotInputInstruction as ITreeSnapshotBlockInput).scope = (\n                            args['scope'] as unknown as ICodeInstruction[]\n                        ).map((item) => __buildInputSnapshotInstruction(item));\n                    }\n                }\n\n                return treeSnapshotInputInstruction;\n            }\n        }\n\n        const snapshot: ITreeSnapshotInput = {\n            process: [],\n            routine: [],\n            crumbs: [\n                (instructions as ICodeInstruction[]).map((instruction) =>\n                    __buildInputSnapshotInstruction(instruction),\n                ),\n            ],\n        };\n\n        generateFromSnapshot(snapshot);\n    }\n\n    return new Promise((resolve) => {\n        if (__verifyStructureValidity() === false) {\n            resolve(false);\n        } else {\n            const snapshot = generateSnapshot();\n            try {\n                __transpile();\n                resolve(true);\n            } catch (e) {\n                console.log(e);\n                generateFromSnapshot(snapshot);\n                resolve(false);\n            }\n        }\n    });\n}\n\n/**\n * Resets the program — generates an empty Syntax Tree.\n */\nexport function resetProgram(): void {\n    resetSyntaxTree();\n}\n","abstract class SyntaxError extends Error {\n    private _name: string;\n    private _message: string;\n\n    constructor(name: string, message: string) {\n        super(message);\n        this._name = name;\n        this._message = message;\n    }\n\n    public toString(): string {\n        return `${this._name}: ${this._message}`;\n    }\n\n    public get type(): string {\n        return this._name;\n    }\n}\n\nexport class InvalidInstructionError extends SyntaxError {\n    constructor(message: string) {\n        super('InvalidInstructionError', message);\n    }\n}\n\nexport class InvalidArgumentError extends SyntaxError {\n    constructor(message: string) {\n        super('InvalidArgumentError', message);\n    }\n}\n"],"sourceRoot":""}